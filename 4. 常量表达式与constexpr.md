## day4:函数的形参与实参

##### 使用引用作为形参的好处

避免拷贝 返回额外信息

##### 形参的初始化方式和变量的初始化方式是一样的

因此，透彻的理解变量的初始化机制

##### 尽量使用常量引用

原因 

我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参

##### 数组形参

首先我们考虑数组的两个性质：

1. 不允许拷贝和赋值：不允许用数组的内容初始化另一个数组或者用数组给另一个数组赋值。这就意味着我们不能通过值传递的方式使用数组参数。

> 一些编译器支持数组的赋值，这就是所谓的编译器拓展。

2. 数组的名字常常被一个指向数组首元素的指针代替。 

#### const与constexpr

http://c.biancheng.net/view/7781.html

https://www.zhihu.com/question/35614219

常量表达式，指的是值不会改变并且在编译过程中就能得到计算结果的表达式。字面值属于常量表达式。用常量表达式初始化的const对象也是常量表达式。

> 用常量表达式初始化的对象不一定是常量表达式！必须是用常量表达式初始化的const对象！

```c++
const int i=42;  //i是一个常量表达式，在编译时初始化。注意这里我并没有将i声明为constexpr，但它仍然在编译时初始化了。这说明什么？
const int i=get_size(); //正确编译，但是在运行时才会初始化。
```

可以发现，const对象初始化时有两种情况：一种是用常量表达式进行的初始化，另一种用非常量表达式进行的初始化。我们把用常量表达式定义的const对象也认为是常量表达式。

```c++
constexpr int i =0;
```

存在一个问题，用const定义时，我们很难知道初始值究竟是不是常量表达式。现在我们引入constexpr关键字，首先它要求初始值必须是常量表达式，所以编译时会进行检查，不是的话会报错。

constexpr就等价于用const修饰的常量表达式初始化的const对象

```c++
const int a=5;
constexpr int a=5;
//二者相比，当初始化的值为常量表达式时，constexpr比较const多了一个检查初始值是否为常量表达式的功能，二者都是在编译期间初始化的。在编译期间计算出结果，在运行期间不需要再次计算，提高运行速度。
```

注意，常量表达式与constexpr并不是一致的。我们可以说一个字面值是常量表达式，却不能用constexpr关键字去修饰字面值。

constexpr的出现彻底地区分了const的双重语义“常量”和“只读”。

constexpr变量变成了真正的常量。const的基本语义现在可以被理解为是“只读”，是否是常量并不确定。

现在我们来定义constexpr出现之后常量和只读的含义：

常量：编译时就可以获知结果且并不会改变的变量

只读：初始化后值并不会被程序改变的变量。但是初始化的值可能不会在编译时就获知。

**我们可以说，常量必然只读，但只读不一定是常量。**

**constexpr的作用是否完全覆盖了const？**也不是，因为还存在一部分const对象，它们的初始化值要等到程序运行的时候才能获取。




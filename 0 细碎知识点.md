## 2.1.3 字面值常量

 每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

指针字面值nullptr ：nullptr可以用来初始化一个空指针。

```c++
int *p=nullptr;
int *p=0;

#include<cstdlib>
int *p=NULL; //NULL是预处理变量，它的值就是为0
//以上三种方法都可以初始化一个空指针，注意第三种方法需要include<cstdlib>这个头文件。最好避免使用NULL
```

我们可以发现，p在定义时仍然指向int类型的对象，左右两边的对象类型并不匹配。这是因为指针字面值nullptr可以被转换成其他任意类型的指针。

> 由此引申来的，可以这样认为，数据类型并不是单独指变量的数据类型，也可以是常量的数据类型。可以用同数据类型的常量来初始化变量或对？变量进行赋值。
>
> 对于自定义类呢？是否有其同类型的常量？用const定义即可。

对于字面值常量来说，其自带顶层const，因此我们不能让一个普通引用指向字面值常量。

```
int *p=42;
const int *p=42;
const
```

我们说，引用的类型必须与其所引用的对象一致。但这只是针对非常量引用而言的。对于常量引用时，并不需要一致，只要=右侧表达式能够转换成引用的类型即可。

```c++
const int &r=true;
//true属于布尔类型常量，而r是指向int类型的常量引用。布尔类型能够转换成整型，因此正确。
```

## 类型转换规则

可以画一个图来进行表示。 

## 2.2 变量

对C++程序员来说，“变量”和“对象”一般可以互换使用。

> 从这一点出，可以进一步理解，所谓自定义类或者标准库类，和内置类型一样，只不过也是一种类型罢了。某种类型的对象即某种类型的变量。

变量的定义

变量声明和定义的关系

##### 复合类型

复合类型是指基于其他类型定义的类型。

> 意思是复合类型必须依赖于其他类型。这里的类型可以是内置类型，也可以是任何标准库类型或者自定义库类型。如果其他类型不存在，那复合类型也将毛之焉附。

已知的复合类型有：引用，指针，数组。、

### 获取变量类型并输出

https://www.cnblogs.com/0patrick/p/12864894.html

```c++
#include<typeinfo>
int a;
cout<<typeid(a).name()<<endl;
```


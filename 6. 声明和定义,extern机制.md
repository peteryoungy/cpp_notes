

#### 1. 用struct关键字定义类

```c++
struct Sales_item{

    
};  //定义类之后一定要加;
```

**头文件中不可以包含定义，但是有三个例外：类，常量表达式初始化的const对象（或者constexpr变量），inline。**

**类，const和constexpr变量 通常被定义在头文件中。**

**对于用常量表达式初始化的const对象，必须将定义写入头文件中，而不能将定义写在源文件中。对于不是用常量表达式初始化的const对象，可以加上extern放在源文件中，并在头文件中加上extern声明。**

**<u>对于不是用常量表达式初始化的const对象，也可以将定义写在头文件中吗？</u>**

原因是该const对象用常量表达式初始化，那么该对象自身也可以作为一个常量表达式为其他对象初始化，而当它作为常量表达式时，其初始化必须为编译器可见，如果将对象的定义放在源文件中，编译阶段还没有链接到它的定义，因此编译器不知道他的具体初始化式，会报错，因此将它的定义直接都放在.h头文件中，这样编译器可以直接找到初始化式，同时由于const的特性，const对象在定义它的文件中是局部变量，因此即使多个文件包含该头文件，也不会重定义报错。

但经过我的亲身试验，这句话的说法并不准确。如下

```c++
//test.h
extern const int i;
//test.cc
const int i=5;
//main.cc
#include"test.h"
int main(){
    constexpr int k=i;   //这里会报错，因为我们试图用i去初始化常量表达式K,但是由于i的声明和定义是分离的，对main,cc编译时，并没有链接到test.cc，因此在编译时编译器并不知道i的值，因此就会报错。
    //但是怎样就不会报错了呢？那就是我并不试图用i作为常量表达式的性质去初始化任何一个常量表达式。例如在main函数中我这样写：
    const int k=i; //这里就不会报错了，因为对于const对象的初始值，既可以是编译时初始化（即在编译器就获知其值），也可以是运行时初始化。
}
```

函数难道可以被定义多次？不可以啊。所以函数定义不应该写在头文件中。

变量不可以被定义多次。

**<u>类可以被定义多次吗？为什么类必须写在头文件中？</u>**百度上说，一般类的定义都是放在头文件中的，好像懂了一点，写在头文件中是为了给使用类的人说明一下类本身有哪些成员和方法。具体方法的实现，可以不写在头文件中而在源文件中定义。这样相当于只提供接口，但不会给你提供具体代码，完成闭源。

但其实也可以做到如函数那般，声明放在头文件中，定义放在cpp文件中。不可以！

##### 声明和定义的关系

顺序很重要，如果前面出现了定义，那也可以认为已经声明过了。定义包含了声明，但声明并不包含定义。定义指的是已经给该变量分配了存储空间，而声明并没有。

#### 2. 头文件中的变量定义，extern机制与extern const机制

https://blog.csdn.net/liuhhaiffeng/article/details/82623785

##### 2.1 几个当时提出来的傻瓜问题

<u>在头文件中出现的变量，都要加上extern为了声明而不是定义它。extern出现的作用就是将声明与定义分离了。但是，如果我就是想声明并定义呢？</u>也可以，只不过是两种机制罢了。不可以！普通变量绝不可以在头文件中定义！

<u>但是对于const变量，不可能存在只声明不定义的情况，而且定义时一定要要初始值。那也没什么吧，就这样呗。</u>问题大了，难道你就不会担心const变量被多次定义吗？

<u>那extern 对const有用吗？用extern 修饰const时，我们可以不给const对象初始化吗？</u>有用，可以。

默认情况下，const对象被设定为仅在文件内有效。我们仍然可以使用头文件机制，但是，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。例如a.cpp和b.cpp同时#include c.h 在c.h中定义了一个const变量i,则在a中的i与在b中的i，其实时两个const对象。

<u>这样做的目的是什么呢？</u>目的是为了让const变量即使是在头文件中定义了，也不会产生多次定义的问题。

<u>有办法让多文件共享const对象吗？</u> 有办法，就是利用extern将const变量的定义与声明分离。

##### 2.2 机制剖析

```c++
// a.h
int i=5;       //不可以。如果有多个文件引用了a.h,会出
//变量被多次定义的问题。
const int k=5;  //可以。多个文件引用a.h 都会在自己的作用  //域内生成一个同名的const变量，编译器并不会报错。


//b.h
extern const int b;

//b.cc
const int b=6;
//使用声明与定义分离的方式定义的const变量会在多文件内共享。
```

在头文件中定义变量，如果有多个文件引用了该头文件，那该变量将会被多次定义，所以前面就说过了，头文件中不要放定义，要放声明！
这是对于普通变量而言的。对于const变量怎么办呢？const变量必须初始化，也就是说const变量从理论上来说，是不能把声明和定义分离开来的。谁说的，这不是有extern吗？
既然这样的话，那我就在头文件中声明const变量，在源文件中定义const变量。有了const，终于能把声明和定义分离开了，对于const变量，这绝对是一个好消息！


但其实，C++对于const变量，有一个小小的“退让”：在头文件中可以定义const对象并且编译器不会认为多次定义。
编译器处理的办法是，认为const变量仅在本文件内生效，也就是说，其实不同文件中的const对象不是一个，而是多个副本。

那有办法让多文件共享同一个const对象吗？有，那就是用前面提到过的办法，和普通变量相同的办法，使用extern关键字在头文件中声明，在源文件中定义。

因此，我们可以知道extern的内涵 ：

1. 强行将定义语句转化为声明语句，实现声明和定义的分

2. extern修饰的对象，必定是被多文件共享的。

头文件中不能定义普通变量，但能定义const变量。使用这种方式定义的const变量在每个使用它的文件内是一个单独的副本。

**<u>在一个源文件中，若它引用的多个头文件含有同名的const变量，怎么办？</u>**

先不要说const变量，如果是同名的普通变量怎么办，那当然就会提示重复定义了，本来就不应该定义重复的变量名字，为什么还要去做呢？但是对于const变量是有一些特殊的，我们知道const变量如果定义在头文件中，那在引用该头文件的文件中实际上会生成一个同名的副本对象，而不是直接使用原对象。那又怎么了，这是两码事，在同一个文件中重复定义同名变量就是有问题！

#### 3. ifndef define endif机制

```c++
#ifndef SALE_DATA_H
#define SALE_DATA_H
//中间放入所有的文件内容

#endif

这样，仅有在第一次引用该头文件时，使用到里面的内容，后面再想引用该头文件，并不会访问到里面的内容了，这样可以防止在同一个文件多次引用同一个头文件。
    
事实上，我们并不需要担心标准库头文件被多次引用的问题，因为它们也全都采用了这种机制。我们只需要关心的是，在写自定义头文件时，记得使用这样的机制来防止该头文件被多次引用。同时，源文件中其实并不需要采用ifndef机制，
```



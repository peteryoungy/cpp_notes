## IO类

##### 如何深入理解cin cout？

每个流对象都管理一个缓冲区。

当程序中出现了

```c++
cin>>
```

程序会做以下的事情：

1. 等待用户的键盘输入，以回车键为信号，当用户按下回车键时，用户不得再输入，并将回车之前的字符全部加载到cin所管理的缓冲区中。
2. 从cin缓冲区中读取内容，并根据变量类型进行匹配。

当程序中出现了

```c++
cout<<
```

程序会做以下的事情：

1. 将用户想要输出的内容加载到cout所管理的缓冲区中。
2. 等待一个缓冲区刷新的信号，当接收到该类信号，将缓冲区中的内容显示在console中。

对于C++程序本身而言，将cin和cout理解成其所管理的缓冲区，就会好理解了。而缓冲区与计算机的输入输出设备的交互（键盘输入，内容显示）细节，我们不必关心。这一部分的实现应该是在iostream头文件中吧？不知道未来有没有机会可以深入了解一下它的机制。

<< >>其实本来是左移右移运算符，但是istream和ostream类对运算符进行了重载。返回值是左值。

### 简介

##### C++标准库提供的IO库架构

```c++
//IO类概览
//头文件名   类名       
iostream	istream
    		ostream
    		iostream    
fstream		ifstream
    		ofstream
    		fstream
sstream		istringstream
    		ostringstream
    		stringstream
```

##### 继承关系



### 条件状态

IO在使用时非常容易发生异常。因此在使用时有必要检测其状态，前面其实已经用到：

```c++
while(cin>>word)
```

每次执行while语句，都隐含地对cin流对象进行状态检测，如果不能正常使用，返回false，跳出循环。

```C++
//T代表任何一种IO类型
//类类型
T::iostate
//类数据成员:类型全部都是constexpr T::iostate
T::badbit	//一般是发生系统级错误时，这是难以修复
T::failbit	//可以被修复的错误，如给变量传入类型不匹配的值
T::eofbit	//遇到文件结束符
T::goodbit	//正常置0
//类方法 c代表任何一种IO类对象
c.bad();	//当badbit被置位，返回true
c.fail();	//当failbit被置位，返回true
c.eof();	//当eofbit被置位，返回true
c.good();	//当badbit,failbit,eofbit都未被置位，返回true
//以上四种方法都会去检测该对象对应的状态flag,如果该状态被置位，则返回true。注意：当
c.rdstate();
c.setstate(flag);
c.clear(flag);
c.clear();
```

### fstream独占操作

```C++
T fs;		//创建流对象fs，但未初始化其绑定的文件
T fs(s);	//s代表文件名，可以是字面值常量或C风格字符串，创建流对象fs，并执行fs.open(s)
fs.open(s);	//打开文件s，并将流对象fs与s文件绑定
fs.open(s,mode);  //以mode方式打开s,并将流对象fs与s绑定
fs.close();	
fs.is_open()   //
```

##### 文件模式

```c++
in
out
app		//与trunc相对，在原有文件上继续写
trunc	//文件截断：指文件被重置为空白文件


```

- 对于ifstream，不允许其文件模式为out;对于ofstream，不允许其文件模式为in。
- 不显式指定时，out模式自动为trunc模式
- 对于ifstream，其默认文件模式为in，对于ofstream，其默认文件模式为trunc（out）

```c++

```



### sstream独占操作

```c++

```

### 缓冲区的刷新

每个输出流都管理一个缓冲区。

很多时候，当我们使用cout<<，其内容不会马上输出，这是因为还保存在缓存区中，没有立即刷新。这种机制让我们可以避免多次使用设备读写，提高效率。

缓冲区会在以下时刻进行刷新：

- 当程序执行完毕时
- 当从相关联的流读写数据时
- 当显式使用endl刷新缓冲区时
- 当使用unitbuf操纵符时
- 当缓冲区已经满时

当程序崩溃时，缓冲区没有立即刷新。因此，当发现你想要的数据没有输出时，考虑一下是否是缓冲区没有刷新的缘故。

##### endl,flush,ends

endl:立即刷新缓冲区，并在最后加一个换行符

flush:立即刷新缓冲区，后面什么也不加

ends:立即刷新缓冲区，并在最后加一个空格

##### unitbuf & nounitbuf

```c++
cout<<unitbuf  //任何数据立即显式刷新
cout<<nounitbuf  //解除unitbuf状态
```

##### 流对象的关联

只能将一个输入流对象和一个输出流对象进行关联，或者两个输出流对象进行关联。

多个流可以绑定到同一个输出流，但一个流不能绑定多个输出流。

```c++
//tie有两个重载版本
//若tie无参数，返回该对象所绑定的流的指针，若没有绑定，返回空指针
in.tie(); 

//若tie有参数，则该参数是该对象将要绑定的对象指针,返回值如上
//注意：这时候的返回值是还没有与括号里的输出流对象绑定时的返回值
in.tie(&cout)
```


## day3：分离式编译

### 一、分离式编译

#### 1.1 一个分离式编译的例子

函数遵循一次定义，多次声明的准则。为了对函数声明进行统一，我们把函数声明放置于fact.h文件中，任何想使用这个函数的文件只需要#include这个fact.h文件即可。**函数声明**也被称为**函数原型**。

#### 1.2 一个例子阐释分离式编译

1. fact.cc 和main.cc独立编译，形成.obj（.o）文件 .o是目标文件还是二进制文件？**二进制文件就是可执行文件了吧**？
2. 编译器将多个.o文件连接，形成可执行文件.exe。

如果对fact.cc进行了修改，那只需要单独编译.cc即可，不需要再对main重新编译，大大提高了编程效率。

> **问题：如果a.cc中用到了b.cc，a.cc重新编译，需不需要重新编译b.cc呢？当然不需要了，这不就是分离式编译所带来的好处吗？**已经试验过就是不需要。

> **问题：如果在linux中，生成什么格式的可执行文件呢？** .out格式，Windows中是.exe。
>
> **问题：为什么fact.cc也需要#include"fact.h"？不这样的话有什么后果？即：为什么定义函数的源文件应该把含有函数声明的头文件包含进来？**
>
> [Reason1](https://wenku.baidu.com/view/bab316291ed9ad51f01df2d0.html): 为了使编译器能够检查声明和定义的一致性。只有把声明和定义放到同一个文件中，编译器才能够进行一致性检查。因此，需要我们让定义函数的源文件也同时包含有函数声明的头文件。
>
> [Reason2](https://www.zhihu.com/question/446925538): 头文件中声明的对象不仅是给外部函数使用，也有可能仅在源文件内部使用。奇怪，那为什么不在源文件内部定义呢？**因为存在这样一种情况：符号可能既要给外部使用，又要在内部使用。**只在文件内部使用的变量，写在文件内就可以了，但是如果这个变量要给外部调用，那就必须放入头文件中。因此，第二个理由理由迫使我们必须这样做，因为在头文件中

如果不是为了在分离式编译时还能使每个文件有效，其实我们仅仅需要单独编译每个文件，并将它们连接起来即可。

**编译器和链接器是不同的东西对吧？我们平常提到的编译是不是默认也进行链接工作？**

**如果不需要的话，为什么----》build的概念**？IDE中build机制

**如果使用标准库中的头文件，工程目录中并不需要加入标准库源文件，编译时会将其与自己写的文件链接吗？**————看第二节 静态函数库与动态函数库



#### 1.3 对.h文件和#include机制的深入理解

https://blog.csdn.net/qq_43746863/article/details/112131037

https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html

##### 由分离式编译引发的问题

分离式编译产生的初衷：是因为程序员想要分离式地编写cpp文件，不想把所有代码都放到一个冗杂的cpp文件中。这样明显是有好处的：我们可以将代码按照逻辑规范划分，模块化地进行开发，同时便于管理。

分离式的编写代码并不会产生什么问题，我们可以先进行模块化的编写，然后将所有代码整合到一个大的cpp文件中即可，

但是程序员们想更加贪心一点，他们提出一种机制：我们将每个cpp文件单独编译，然后通过某种方式把单独编译的文件链接起来，形成最终的可执行文件。我们首先假设这种方式在技术上是可以实现的。这种分离式编译相比于之前版本的分离式开发，有着更加明显的优点：

但这种机制会带来问题。如果我在A文件中使用B文件中定义的符号c（这是很正常的，虽然是分离式开发，但实际上程序员们还是会认为所有的cpp文件属于一个大文件），编译器会报错，因为在A文件中并没有出现c的声明。（c++的语法规定符号必须先声明再使用，因此编译器也会对这里进行语法检查。）那怎么办呢？最简单的解决办法就是如果A文件用到了其他文件中定义的符号，那程序员就去打开其他文件，将该变量的声明copy一份到A文件中，就可以了。如果源文件数量很少，符号很少，这样做还是比较容易，但是想象一下，如果整个项目里面的cpp文件非常非常多，定义的符号也非常非常多，会产生什么问题呢？

1. 对于文件A，只要用到了其他文件B中定义的符号，都需要执行以下步骤：打开B文件→找到该符号的定义→copy到A中→打开下一个文件。如果A用到了几十个甚至几百个其他文件，这项工作会变得无比繁琐。
2. 如果上一个问题你觉得还能够接受，不就是麻烦一些吗，那么下一个问题会直接将你击溃。如果写B文件的程序员发现其中的某个符号c定义错了，需要重新修改其定义和声明，那么问题来了：工程中所有用到该符号c的地方全部都需要改动！每进行一处符号改动，所有用到该符号的位置需要全部改动，可以想象这个工作量。

##### #include机制与.h文件的产生

如何改进呢？上面两个问题中，问题2是比较致命的。我们首先着手于问题2的解决。问题2的关键就在于每个文件各自使用自己写的声明。如果有一种办法，让所有使用该符号的文件都使用一条统一的声明，如果想修改修改，程序员只需要修改那一句指令即可。这就是.h文件和#include机制的由来。#include<filename>机制我们可以理解为将filename中的代码复制一份到本文件中。文件B将其符号声明写入.h文件中，并命名为B.h，在A或所有用到B中符号的文件中，我们使用#include"B.h" 将声明copy到自己文件中。声明如果需要修改，仅需要修改B.h文件中的声明即可。

由此我们也可以理解#include为什么必须写在文件开头了：#include的本质就是一堆声明。由于对象必须在使用之前声明，因此我们放到最前面，保证后面程序能够正常使用。

##### 对.h格式的理解

实际上.h文件并不是什么新颖的格式，其实质也就是一堆cpp代码。

**.h的意义在于里面存放的内容，而不在于后缀名本身**：函数，变量声明，宏声明，结构体声明等内容。尽管.h后缀并不重要，但是为了其他程序员能够清楚的知道文件的意义，一般对于含有这类内容的文件，都命名为.h

.c文件是程序文件，内含函数实现，变量定义等内容。

##### #include格式

```c++
#include<>
#include""
<>表示，从编译器默认的路径中去寻找头文件
编译器默认路径下，包含了C标准库所需要的所有头文件

“” 表示从当前目录下寻找头文件，如果当前目录下找不到，在从编译器默认路径中查找，
```

 **问题1：编译器的include默认路径如何查询和修改呢？在IDE中？在命令行中？**已经找到在IDE中添加查询路径的办法。既然可以添加，那就没必要修改了。

 问题2：头文件的存放位置问题。 必须加入到工程目录里面吗？

 跟.cc不同，头文件并不需要加载到工程目录里面，#include命令会自己找。头文件也并不一定要放置于工程目录中，可以在添加include添加头文件的路径，或者在#include“”中使用相对或绝对路径。对于任何头文件，无论是函数库（标准库或自定义库）还是放在工程里面的头文件，位置都是无所谓的。

 问题3：如何定义头文件的寻找路径？见2.2

 问题4：关于源文件的存放位置问题

 //源文件的路径呢？源文件要放到工程目录里面，否则就会找不到。//有没有办法不通过copy到工程目录的方式使用源文件呢？

 //假设这样一种情况，函数源文件并不存在与工程文件目录中，那编译器该如何寻找呢？.cc文件必须跟其他.cc处于同一个工程目录下吗？

编译器不会报错的，只要include头文件，就会编译成功，但是在链接时，会因为找不到源文件而报错。

#### 1.4 在Windows中使用g++体验分离式编译

[参考](https://blog.csdn.net/ljjjjjjjjjjj/article/details/80261075)

![image-20210331232350339](day3.assets/image-20210331232350339.png)

配置环境变量：此电脑-高级系统设置，找到系统变量中的Path，点击编辑

配置好环境变量后，需要重新打开cmd才会生效。

Windows中的ls命令：dir

```sh
gcc -c main.cc fact.cc #生成main.o fact.o文件
gcc main.o fact.o #连接两个.o文件生成.exe文件，默认名字为a.exe 如果想修改在命令里加入-o参数
gcc main.o fact.o -o mine.exe
```

**问题：为什么编写的程序控制台就闪一下就消失？**

[参考](https://zhidao.baidu.com/question/547293129.html)

程序执行完之后自动关闭控制台，可以加上等待语句，防止程序一闪而过。

```C++
//文件开头引入头文件
#include<windows.h>
//在程序的最后加上这一句
system("pause")；

```

**对于IDE中的工程，怎么知道链接时用的是静态库还是动态库？如何控制使用静态库或者动态库**

#### 1.5 在Linux中体验分离式编译

Linux中用什么编译器 gcc，使用方法同上

make指令？configure指令？makefile又是什么

#### 1.6 compile make build

compile：

make：

build 彻底编译整个工程文件，不管之前是否被编译过。因此就会出现我删掉fact.cc却没有删除fact.o后，点击build仍然失败的原因，如果是compile，可能就对了。

事实上，在工程目录里删除fact.cc之后（并不是真正在目录里删除，只是IDE显示我删除）如果我不对其他文件做任何改动，点击build，它并不会重新彻底编译，而是提示我所有文件都是最新版本，但如果稍微改动一点，就会提示我找不到fact（）。

![image-20210331222620508](day3.assets/image-20210331222620508.png)

这其实和build定义不符。那么IDE中的build是有更新之后才会进行彻底编译吗？

> 其实可以把用到的所有.cc文件想象成一个它们合并起来的大文件。分离式编译的好处就体现在我们可以分模块编程，而不需要把所有东西都聚集在一个大文件中。



### 二、 静态函数库与动态函数库

https://www.cnblogs.com/skynet/p/3372855.html

##### 2.1 静态函数库与动态函数库的含义与优缺点

静态库直接用于链接过程。静态库文件可以被认为是经过压缩打包的.o文件集合。

动态库在编译过程（编译+链接）中并不会与目标文件链接，而是在程序运行过程中调用。

使用函数库的好处在于我们跳过编译环节直接进入链接环节，库函数的源代码.cpp文件并不需要我们手动编译。使用自定义函数库就如同在使用C++标准库一般。

##### Windows/Linux 库文件的后缀

静态库 .lib/.a

动态库 .dll/.so

**这些文件的本质是什么类型的文件？目标文件？可执行文件？**

如何在编译时指定使用静态函数库或者动态函数库?



##### 在Codeblocks中使用自定义静态函数库完成阶乘

[参考](http://www.360doc.com/content/16/0517/09/33377968_559799278.shtml)

步骤：1. 生成自定义静态库。2.在程序中调用静态库

在其中用到了如何在IDE中设置include头文件的寻找路径和库文件寻找路径。





编译时,源文件可以处于不同目录吗？copy下来能咋？这样做的意义是什么？为什么要把源文件放在不同的目录里呢？如果能实现在IDE和命令行里如何实现呢？



#### IDE中的DEBUG与Release

##### Debug 版本

Debug 是“调试”的意思，Debug 版本就是为调试而生的，编译器在生成 Debug 版本的程序时会加入调试辅助信息，并且很少会进行优化，程序还是“原汁原味”的。

你没听错，不是任何一个程序都可以调试的，程序中必须包含额外的辅助信息才能调试，否则调试器也无从下手。

##### Release 版本

Release 是“发行”的意思，Release 版本就是最终交给用户的程序，编译器会使尽浑身解数对它进行优化，以提高执行效率，虽然最终的运行结果仍然是我们期望的，但底层的执行流程可能已经改变了。

编译器还会尽量降低 Release 版本的体积，把没用的数据一律剔除，包括调试信息。

最终，Release 版本是一个小巧精悍、非常纯粹、为用户而生的程序
## 函数

函数是一个命名了的代码块，我们通过调用函数执行相应的代码。

我们通过**调用运算符**来执行相应的代码。

### 函数类型与函数指针

函数也是有类型的，从这个角度看，可以将其暂且当做一个变量。函数的类型由形参类型和返回类型共同决定。

```c++
bool compare(const int &a,const int &b){}
//compare的类型是bool (const int &a,const int &b)
```

指向函数的指针类型

```c++
using PF = bool (*)(const int &a, const int &b);
// 注意，*的括号必须带着
```

函数指针也属于函数对象的一种。指向不同类型函数的指针之间不存在互相转换。

调用运算符可以作用于函数或者函数指针。

```c++
bool b1 = PF(a,b);
bool b2 = compare(a,b);
```

当我们把函数名作为右值使用时，自动转换成指针。

```c++
PF = compare;
PF = &compare;
//皆可
```

使用decltype推断

```c++
decltype(compare) //得到函数的类型
decltype(compare) * //得到指向该函数的指针
```

函数不能返回函数，但可以返回函数指针。

```c++
bool isGreater(int &a,int &b){
}
bool isless(int &a,int &b){
}
using pf = bool (*)(int &a,int &b);
pf whichfunc(string func){
	if(func==greater){
		return &isgreater;
	}
	else{
		return &isless;
	}
}
```

同样，函数不能作为函数形参，但函数指针可以。



### 函数形参

函数形参有两种形式，一种是引用形参，另一种是。

#### 1.1 可以是形参的类型

**不能使用数组作为形参。**因为前面已经提到，数组名在编译器中会被当作指向数组首元素的指针对待。尽管如此，我们仍然可以传入该指针，以使用这个数组。

当使用指向数组元素的指针作为形参时，需要确定

#### 1.2 形参的初始化

函数调用时，使用实参对形参进行初始化。 初始化的规则如同变量初始化的规则。

> 因此需要对各种变量的初始化规则熟练掌握，尤其是关于引用、指针的初始化以及const对象的初始化。

#### 1.3 使用引用形参的好处

避免对较大对象的拷贝工作

使用引用形参可以产生“多个返回值”的作用

#### 1.4 使用const形参的好处

当不会对传入的对象进行修改时，尽量使用const形参。const形参能够接受常量，字面值常量，和需要进行类型转换的对象作为实参。而非const常量不行。使得函数的灵活性和易用性大大提高。

#### 1.5 使用数组作为形参

###### 1.5.1 几个概念

首先我们要明确几个概念，数组名a，指向数组首元素地址的指针p1，指向数组的指针p2，数组的引用r。

1. a与p1的关系：在一般情况下，数组名被当作指向数组首元素地址的指针，即p1，除了两种情况：sizeof() 和&

```c++
int arr[10];
cout<<arr;
cout<<&arr[0];
//二者结果相同
```

2. p1与p2的关系：p1与p2的值相同。但也仅仅是值相同，p1+1与p2+1的行为完全不同。前者代表数组中第二个元素的地址，后者指向数组末尾地址的下一个地址。换句话说，只有p1有访问数组元素的功能，p2没有办法访问数组元素。

**<u>编译器是通过什么方式区分数组的指针和指向数组首元素地址的指针呢</u>？**

```c++
int arr[10];
cout<<arr;
cout<<&arr;   //&arr就代表指向数组的指针
cout<<arr+1;
cout<<&arr+1;
```

由于使用数组的指针无法访问数组内元素，因此想要将数组作为函数的形参，只有可能有两种方式：使用数组的引用，或者使用指向数组首元素地址的指针（数组名）。

###### 1.5.2 指向数组首元素的指针作为函数形参

```c++
print(const int *);
print(const int []);
print(const int [10]);
//以上3种写法效果都是一致的，即接受一个指向整型常量的指针（编译器是这样认为的。但我们心里要知道，这是一个特殊的指针，它代表一个数组的首地址。）
```

指向数组首元素的指针，并不包含数组的长度信息。也就是说，就算函数获取了数组首元素的地址，它并不知道数组最后一个元素在哪。（除了C风格字符串有明显的结束标记）因此，**为了能够管理指针的行为，在使用指向数组首元素的指针作为函数形参时，必须还要向函数提供与数组长度有关的信息，以防访问越界。**一般来说有以下三种方式。

- 使用标记指定数组长度。要求数组有明显的结束标记，例如C风格字符串，不适用于没有特殊标记的数组。
- 传递指向数组首元素和尾后元素的指针。

```c++
void print(const int *beg,const int *end)
```

- 显式传递数组大小。（这个很容易理解就不举例了）

###### 1.5.3 数组引用作为函数形参

```c++
void print(int (&arr)[10]) //注意，这里写的是10就必须是传入大小为10的数组，多了少了都不行，详情参考数组引用和数组指针的初始化规则。
```



#### 1.6 如何定义可变数量形参的函数？

在C++11标准中提出了两种方法来定义含有可变数量形参的函数，这里将会提到一种，即使用iterator_list

###### 基本操作

为什么使用iterator

### 函数返回值

##### void类型返回值

void类型返回值有两种表达方式：

```c++
return;
return expression;//使用 第二种时，expression必须是一个能返回void类型的函数
```

对于第一种形式，当需要放在函数最后时，可以选择不写。但也可以写在函数体中间，获得一种类似“break”的效果，立即退出函数。

##### 其他类型返回值



#### 总结：如何理解复杂的类型声明，与typedef机制

与名字最先结合的即为它的本质,剩余部分变成基本类型对待。

```
* & []都是属于复合类型的声明符，其中[]后置于名字，* &前置于名字，最先与名字结合的符号定义了其本质，剩下的基本数据类型与剩下的符号结合，形成语义上的基本类型。结合优先级为()>[]>& =*
int (&arr)[10] //本质是引用，作用于基本类型为整型数组
int *parray[10]  //本质是数组，作用于基本类型为整型指针

```

这一点在阅读复杂的类型定义时非常有用，还有一处，就是理解别名定义

```
typedef char *pstring;   //可以这样理解，定义别名即定义了一个基本类型char* 指向char的指针
//这里只取名字，除了名字剩下的部分变成类型，【】仍然后置
const pstring cstr=0;   //const作用于char指针，因此cstr为指向char类型的常量指针，这里const的作用是顶层const
什么时候作用于指针是底层const呢？
注意：不能直接将pstring替换，我们来看替换之后：
const char *cstr=0;  // *最先与cstr结合，本质是指针，指向const char类型。
没展开之前，基本类型是char *，展开之后，基本类型是 *，由此可见，这里别名竟然有一种，指定多个单元成为其本质的作用，因为在普通的定义中，本质只能是最先结合的那个，但是在定义了别名之后，本质可以是多个单元的结合，在这里就是 char*作为本质，而不是* 
```


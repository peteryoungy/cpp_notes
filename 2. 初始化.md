## day2: 初始化

##### 参考页码

P39默认初始化 P65类内初始值的初始化 P76string初始化方式，直接初始化与拷贝初始化

P88 vector初始化方式，列表初始化，值初始化 P185局部静态变量的初始化

##### C++初始化分类

**分为拷贝初始化和直接初始化两种。区别在初始化时是否使用“=”，使用“=”的即为拷贝初始化，不使用“=”为直接初始化。**实际上，拷贝初始化可以看做是对C语言语法的一种兼容。

列表初始化：使用{}进行初始化的方式。与前一种分类不冲突。

##### C++ 初始化举例

```c++
1. int i = 0;
2. int i = {0};
3. int i{0};
4. int i(0);

5. vector<int> a = {1,2,3,5,3,5,6}
6. vector<string> a{"as","dvf","sds"};
7. vector<int> a(10,5);
8. string a(10,'c');
```

对于某些变量，可能不支持以上的某种操作，下面我们来一一分析。

1. 多元素列表初始化5号和6号，仅在vector中支持。在列表中放置多个元素的初始化方式，string并不支持，而且string也不支持单个元素列表初始化。

   ```c++
   string a = {"asas"} //错误，string不支持列表初始化，即不可以用任何带{}的方式对string初始化
   ```

2. 7号和8号，string和vector都支持通过（元素数量,初始值）的方式初始化。对于string，初始值要填入单个字符。**“”和‘’的区别？** 对比于string，vector还支持仅提供元素数量，不提供元素初值的初始化方式，其内成员的将执行[值初始化]()。

   ```c++
   string a(10,'c')；
   vector<int> b(10,5);
   vector<int> c(10);  
   vector<string> d(10);
   ```

3. 普通变量对于1,2,3,4都支持。但对 [类内初始值](#类内初始值)，仅支持1,2,3,不支持4号圆括号的初始化方式（因为这种方式会被编译器认为是函数声明？[参考](https://www.zhihu.com/question/37019538)）

   [类内初始值]()用于对象创建时初始化数据成员，没有初始值的成员将被[默认初始化]()

- [ ] ##### 总结vector和string的所有初始化方式








##### 默认初始化

规则：

1. 对于C++ 内置变量类型，初始化的值与其在文件内被定义的位置有关。若变量定于于任何函数体之外，则初始化为0；否则，将不被初始化。被初始化一个未被定义的值。

**定义在函数体内部的内置类型变量，如果在定义时不含有初始值，那它将不被初始化，一个未被初始化的内置类型变量的值是未定义的。如果试图拷贝或以其他方式访问此类值将会发生错误。**



1. 对于类，初始化的值由类决定。这里分两层。有的类要求在定义时必须初始化，并不允许不给予初始化的情况出现，如果出现这种情况，将会被报错。有的类则允许在定义时不被初始化，对于这种情况，类内要规定初始化的值。

应用场景：

1. 类的数据成员没有类内初始值时
2. 定义变量时没有指定初始值
3. 定义数组时没有指定初始

……

##### 值初始化

1. 对于C++内置变量类型，初始化为0
2. 对于类，初始化的值由类决定。同样也分两层。这里不再赘述，看默认初始化即可。

应用场景：

1. vector没有提供初始值时，或部分元素没有被提供初始值时
2. **局部静态变量**没有被显式初始化时
3. map中的key不存在时使用

……

[参考](https://www.dazhuanlan.com/2019/12/13/5df30336b5051/)


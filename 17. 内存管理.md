## 内存管理

##### 使用delete面临的风险：

- 忘记delete。忘记释放的内存没有办法被释放。**操作系统是如何解决这种问题的呢？**

- delete一个指向非动态内存的指针。

  delete的指针要求必须指向动态内存。但是编译器并不能分辨指针指向的是动态还是静态内存，这样的代码通常会编译通过。其产生的行为是未定义的。

- delete一个已经被释放的指针。

  同样，编译器同样无法分辨指针指向的内存是否已经被释放。因此，delete一个可能已经被释放内存的指针也会产生未定义的行为。

> 目前不也不清楚未定义的行为是没有影响还是可能会带来不好的影响，但是对于未定义的操作我目前的观点还是不要触碰

- 使用delete之后的指针

  对于有些编译器，delete之后的指针很可能仍旧保存着指向的动态内存的地址。

shared_ptr默认其指针指向的是动态内存。因此在shared_ptr被销毁时它会调用delete对其指向的对象进行销毁。



一个问题：有些时候某些类型的析构函数是删除的。也就是说我们不能通过delete p的方式销毁指向该对象的指针。这种情况有解决办法吗？那就是使用智能指针并在定义智能指针对象时指定一个删除器。该删除器定义了如何销毁p指向的对象。

另一个问题：一个析构函数是删除的对象真的有办法进行销毁吗？

那些无法被销毁的类型都是从哪里来的？手动置为 delete吗？

### 智能指针

shared_ptr，unique_ptr，weak_ptr均被定义在<memory>头文件中

类似于容器的使用，定义类型时必须使用<>明确该智能指针所指向的对象类型。

##### 初始化

可以使用**同类型智能指针**初始化，也可以使用**指向动态内存的内置指针**初始化。默认初始化为空指针。

```c++
shared_ptr<int> p;
shared_ptr<string> p=make_shared<string>("smart pointer");
shared_ptr<string> p(new string("normal pointer"));
```

###### make_shared<>使用

```c++
make_shared<Typename>(args);
//args是用于构造该类型对象的参数，类似于容器插入操作中的emplace函数，将args传入其对应的构造函数中完成初始化。
//对于内置类型，括号里放想要初始化的值进行初始化。空括号进行值初始化。不带括号进行默认初始化。
```


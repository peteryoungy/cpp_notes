## 第十章 泛型算法

### 0. 简介

泛型算法通常情况都会接受迭代器作为其参数。同时泛型算法接受谓词作为其最后一个参数，用以定制其操作。

我们并不给出每个算法的使用方式，而是要给出使用算法的方法论。因此研究迭代器和谓词，是使用泛型算法的关键。



之前提了一个现在看起来可能很傻的问题：

为什么顺序容器不提供查找这种操作，而在关联容器中提供find函数？

其实标准库使用泛型算法定义了这些功能，可以应用于不同元素类型的不同容器中，== 那么在map和set中还能使用吗？==

```c++
int val =42;
vector<int> val = {}
auto result = find(vec.begin(),vec.end(),val);
```

通常这些算法会要求我们提供一个迭代器范围（我们称之为**输入范围**），用于指示算法的作用范围。

由于算法被提供的参数是迭代器，因此算法执行的是迭代器的操作而并不能直接执行容器的操作。因为它无法访问容器名字。

进一步思考：迭代器的操作并不能改变容器的大小。**因此，泛型算法并不会改变底层容器的大小。**

标准库定义了一类特殊类型的迭代器：插入器。它可以完成向容器中插入元素的操作。但这是迭代器本身支持的操作，泛型算法本身并不具有这样的能力。



但是迭代器类型应该是定义在容器内的吧？

vector:：iterator

算法可能会依赖于元素类型的操作。



**虽然绝大多数算法都提供了相似的输入范围，但它们使用范围中元素的方式不同。**理解一个算法最基本的就是了解他们是否读取元素、改变元素或是重排元素顺序。

### 1.1 只读算法

```c++
find
count
accumulate // <numeric>
equal
find_if //对每个元素调用谓词，返回第一个使谓词返回true的迭代器。接受一元谓词
for_each //对每个元素调用谓词。接受一元谓词。
```

find

```

```

count

```

```

##### accumulate

```c++
T result = accumulate(vec.begin(),vec.end(),T t);
eg:
vector<int> nums = {1,2,3,4,5,6,7,8,9,10};
int sum = accumulate(nums.begin(),nums.end(),0);
vector<string> v = {"I"," love"," you"};
string sum = accumulate(v.begin(),v.end(),string(""));

```

accumualate对输入范围中的所用元素调用“+”运算符，并返回最终结果。有两点需要注意：
1.只要容器中的元素类型支持“+”或者重载“+”运算符或能转换成可以使用“+”的类型，都可以使用accumulate，例如string类重载了“+”运算符，用于连接两个字符串,就可以对类似vector<string>的容器调用该算法。

2.accumulate函数的返回值由第三个参数的类型完全决定。

在上面第二个例子中，之所以使用string("")而不直接使用""是因为编译器会将""推断为 const char* 类型而并非string类型。

并且在“+”的过程中，容器中的元素也会被转换成第三个参数的类型进行运算。如下例所示，两段代码仅仅是在第三个参数的类型上有所区别，结果大相径庭。

```C++
//eg1:返回6
vector<double> nums = {1.5,2.5,3.5};
cout << accumulate(nums.cbegin(),nums.cend(),0) << endl;
//eg2:返回7.5
vector<double> nums = {1.5,2.5,3.5};
cout << accumulate(nums.cbegin(),nums.cend(),0.0) << endl;
```



##### equal

用于确定两个序列是否相同。它比较两个序列的对应元素，使用“=="运算符，返回true or false

```c++
bool isEqual = equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());

```

前两个参数表示第一个序列的范围，第三个参数表示第二序列的开头。

1. 参数类型形如equal的所有泛型算法（仅使用一个参数表示第二个序列）都假定第二个序列至少和第一个序列一样长，如果程序员不遵循这个约定，会发生什么呢？
2. 两个容器的元素类型不必相同，只要能够使用“==”进行比较就可以，例如string和const char*可以比较，int和bool可以比较等等。

```
PS:对于只读算法，由于不涉及对容器元素的改变，我们最好提供
v.cbegin()和v.cend()作为输入范围。
但是如果你希望使用算法返回的迭代器来改变元素的值，那就需要使用begin()和end()作为参数。
```

### 1.2 写容器元素的算法



### 1.3 重排容器元素的算法

```
sort
unique
```

##### sort

接受一个输入范围，使用容器元素类型的“<”运算符对元素进行排序。最“小”的元素排在最前面。

```c++
sort(words.begin(),words.end());
```

##### unique

接受一个输入范围，将互不相同的元素排在容器前面，重复的元素排在容器后面，返回第一个重复元素的迭代器。

```c++
auto begin_it = unique(words.begin(),words.end());
```

### 2. 定制：谓词与可调用对象

```c++
sort
stable_sort
两个排序算法都可以接受一个一元谓语
对于相等的元素，stable_sort按照其排序前的位置排列，不改变其相对顺序。这就是我们常说的稳定排序。而sort并不是一个稳定排序。
```

==sort和stable_sort底层都用了什么排序算法？==

##### 2.1 定制

定制这个概念的出现大大扩张了泛型算法的应用范围。例如在sort函数中，当我们仅仅使用

```C++
vector<int> v1={9,6,8,7,2,5,1,3,4};
sort(v1.begin(),v1.end());
```

时，sort函数会将v1中的元素按从小到大的顺序进行排列。**这是因为sort函数默认使用了int类型的<运算符对其中的元素进行比较。**如果我们想让容器内元素按从大到小顺序排列，按字典顺序排列，那这个函数不就完全没有用处了吗？**因此，我们发现，在没有“定制”算法行为的时候，这些泛型算法的应用范围是极其狭隘的。**

如果我们能够定制<运算符所代表的意义，那么这个问题不就迎刃而解了么？例如，我们定制两个元素中较大的那个为<,或者定制字典顺序在前的元素为<。**应该是元素的比较方式，而不是<代表的意义吧？**

除此之外，对于某些未定义“<”运算符的元素类型，我们可能也期望对其进行某种意义上的排序，这种情况也是需要我们定制sort函数的行为的。

##### 2.2 谓词与可调用对象

泛型算法中的函数允许接受名为**谓词**的参数，来对其行为进行**定制**。谓词可以是一元谓词和二元谓词等等，不同算法对谓词参数个数的要求也不尽相同。

> 没有三元谓词吗？有

**谓词的本质是可调用对象（callable object），任何可调用对象都可以作为谓词传入泛型算法中。**

**对于一个对象或表达式，如果可以对其使用调用运算符，则称它为可调用的。共有4种可调用对象：函数，函数指针，lambda表达式和重载了函数调用运算符的类。**

### 3. lambda表达式

```
find_if
for_each
```

与函数的区别：

- lambda表达式可以在函数内定义。而我们知道，函数内部不能再定义另外一个函数。
- 同时，函数的局部变量可以作为“捕获值”，被lambda表达式所使用。而一个函数定义不能使用另一个函数中定义的局部变量。

因此，lambda表达式可以看成是一个没有函数名的内联函数。

lambda表达式可以被认为定义了一个无名类型，同时创建了该类型的一个无名对象。

```c++
[捕获值](形参列表)->return type {函数体};
//在实际使用中，捕获值和函数体是不能被省略的。
//即最简单的lambda结构为： []{}
```

```c++
auto f=[]{};   //定义lambda表达式
f();	//调用
```

注意：f的类型并不是lambda表达式的返回值，==具体是什么呢？==

因此使用 auto最为稳妥。

##### 3.1 形参列表

lambda表达式不得提供默认实参。

##### 3.2 捕获列表

- **捕获值必须是函数的局部变量**，在函数外部定义的变量或者**局部静态变量不可以作为捕获值**。但是lambda表达式可以直接使用局部静态变量和在函数外声明的名字。

- 捕获有两种方式：值捕获和引用捕获。值捕获就是将该对象拷贝到lambda表达式中使用。因此使用值捕获的前提必须是该对象类型支持拷贝。

  引用捕获用于直接作用于对象，某些对象并不允许拷贝（如iostream类的对象）或者我们不想值捕获时，可以使用引用捕获。

```c++
值捕获：
int val = 5;
auto f = [val] {return val+1;};
引用捕获：
int val =5;
auto f = [&val] {return val+1;};
//总结： 值捕获直接写变量名字就可以了，引用捕获需要在变量名之前加“&”
```

注意：

①**当使用值捕获时，lambda表达式的捕获值在被定义或创建的时候就被传入，并不是在被调用时传入。而引用捕获的变量值在调用lambda表达式时才被传入。因此程序员要保证捕获的对象在lambda被调用时仍然存在，且其值是我们所期望的。**

因为从lambda表达式的定义到被调用，捕获对象的值可能被程序改变，这是C++所允许的。

```c++
//这里是在定义的同时就马上调用，体现不出
find_if(v1.cbegin(),v1.cend(),[sz](const string &s) {return s.size()>=sz;});

//将lambda的定义与调用分离，使用值捕获
int main(){
    int val=0;
    auto f=[val]{return val;}; //这里的val已经被f获取
    val=42;
    cout<<f()<<endl; //输出0而不是42
}

//当使用引用捕获时
int main(){
    int val=0;
    auto f=[&val]{return val;}; //val并未被f获取
    val=42;
    cout<<f()<<endl; //获取val，输出42而不是0
}
```

②**我们可以从一个函数返回lambda，当使用这种方式时，注意返回的lambda不要包含引用捕获。（与返回值不能是的局部变量的引用相似）**

> 给我们的启示：
>
> ① 能使用值捕获就尽量使用值捕获。同时，尽量避免捕获对象是指针和引用。（引用的本质可以看作是常量指针）
>
> ② 函数定义不要返回使用引用捕获的lambda表达式。



- 隐式捕获：我们甚至还可以“偷懒”，让编译器自己分析捕获哪些变量，这被称为隐式捕获。但是我们需要指定编译器默认使用哪种捕获方式，“=”代表编译器默认使用值捕获，“&”代表编译器默认使用引用捕获。

  如果既想使用值捕获又想使用引用捕获，那就只能指定其中一种作为编译器默认捕获的方式，将使用另一种方式捕获的变量显式地列举出来。注意，在这种情况下，显式列举的变量只能是使用另一种捕获方式的变量，不能显式混用。

```c++
[=]  表示默认使用值捕获
[&]  表示默认使用引用捕获
[=,args]  表示默认使用值捕获，args必须是采用引用捕获的变量
[&,args]  表示默认使用引用捕获，args必须是采用值捕获的变量
在后两种方式中，默认捕获符号必须在前面，在其后面列出使用另一种方式捕获的变量。
```

##### 3.3 返回类型

lambda表达式只能使用尾置返回类型。

1. lambda表达式可以显式指定返回类型。
2. 如果lambda表达式没有显式指定返回类型，则编译器会帮助我们推断。推断原则如下：

① 当函数体只有一句return语句时，返回类型是return的表达式类型。

② 如果函数体不仅仅只有一条return语句，默认返回类型为void类型。

```c++
transform(v1.begin(),v1.end(),v2.begin(),
          [](int i){return i<0? -i:i});
//将函数体替换为等价的if语句
transform(v1.begin(),v1.end(),v2.begin(),
          [](int i){if(i<0) return -i; else return i;);
此时编译出现错误，因为编译器推断该lambda表达式的返回类型为void, 但是实际却返回了一个int类型的变量。
```

这给我们的启示是：**如果lambda表达式的函数体不仅是一条return语句，且我们希望其返回类型是非void的，那么需要我们显式地使用尾置返回类型指定。进一步地，如果lambda表达式不仅有一条return语句，我们尽量要显式地进行指定其返回类型。**

##### 3.4 可变lambda

默认情况下，对于值捕获的变量，不允许修改lambda表达式修改其值。若要修改，必须使用mutable关键字声明。mutable的位置在参数列表之后，函数体之前==在哪里还能用到mutable关键字？==

```c++
int sz = 6;
auto f = [sz]()mutable {return sz+=1;}
cout<<f()<<endl;  //输出
```

对于引用捕获的变量，是否能修改取决于引用所绑定的对象是否是const的。不能修改const对象，但可以修改非const对象。



### 3. 函数绑定

**bind的工作原理？**

对于没有捕获值的lambda表达式，将其转换成函数形式非常容易，而对于有捕获值的lambda表达式，确实是一个问题。

之前使用lambda表达式是因为find_if()要求其谓词是一元谓词。而使用函数我们发现必须传入两个参数才能实现其能。但其实我们可以通过函数绑定解决这个问题。

bind()被定义在<functional>头文件中，它是一个函数适配器，将一个可调用对象转换成另一个可调用对象。同时，将某些参数“绑定”到bind中

```c++
auto newcallable=bind(oldcallable,args);
//调用bind()时，会将参数传入oldcallable函数中
```

```c++
//例如，我们将lambda表达式改写成bind形式：
auto f=[sz](const string &s) {return s.size()>=sz;};

bool check_size(const string &s,std::string::size_type sz){
    return s.size()>=sz;
}
auto check6=bind(check_size,_1,6);
auto checksz=bind(check_size,_1,sz);

//两种形式的写法
find_if(v1.cbegin(),v1.cend(),[sz](const string &s) {return s.size()>=sz;});
find_if(v1.cbegin(),v1.cend(),bind(check_size,_1,sz));

//也可以写成
find_if(v1.cbegin(),v1.cend(),f);
find_if(v1.cbegin(),v1.cend(),checksz);
//看起来bind只是一个换皮形式的check_size函数，后者不能用作find_if的谓语，前者就可以了吗？
//对的，通过bind，我们把sz和bind绑定在了一起，因此函数调用不需要再传入sz参数
//至于你并不想绑定的参数，就通过占位符进行标志。占位符的数字决定了这些参数在bind函数中的顺序。

```

##### 占位符

_n被定义在命名空间std::placeholder中，同时，需要include<functional>这个头文件。

##### bind控制实参的传入顺序

```c++
//将从小到大排列的sort函数变成从大到小排列的函数
sort(v1.begin(),v1,end(),bind(isShorter,_2,_1));
```

#####  lambda表达式 vs.函数

- 当函数体较简单时，使用lambda表达式，当函数体复杂，使用函数。
- 当函数被反复调用时，使用函数；当函数仅在某几处使用，可以用lambda表达式。

### 3. 其他类型迭代器

##### 反向迭代器

forward_list不支持反向迭代器，其他容器类型都支持，因此各自被定义在对应容器的头文件中。

```c++
//生成反向迭代器
a.rbegin(); //返回尾元素的迭代器
a.rend();  //返回首前元素的迭代器
//常量版本
a.crbegin();
a.crend();
```

```c++
//反向迭代器支持的操作
//与正向迭代器相比，++和--的意义发生了颠倒。
++iter  
--iter
    
//以下运算符含义不变
*iter
iter->
!=
==
    
//将反向迭代器转换为正向迭代器
//生成的正向迭代器为iter所指位置的后面元素的位置。
iter.base();
```

```c++
//反向迭代器的类型
reverse_iterator
    
```

**使用反向迭代器的泛型算法可以带来意想不到的反向结果。**



##### 插入迭代器

是定义在标准库容器之外的一类迭代器，引用头文件<iterator>

与其他迭代器不同的是，插入迭代器在进行运算时会调用其底层容器对象的方法。根据类型不同分别会调用push_back(t),push_front(t),insert(p,t)。因此，我们要在确保底层容器支持这些操作的情况下使用插入迭代器。例如，对于vector<int>对象，我们就不能用front_insert（）生成其插入迭代器，因为vector不支持push_front()操作。

```c++
//插入迭代器的类型
back_insert_iterator
front_insert_iterator
insert_iterator
```

```C++
//生成插入迭代器
back_insert(c);
front_insert(c);
insert(c,iter);
//c是容器对象，指的是由某个容器对象生成其插入迭代器。
//insert中的iter指定其生成的插入迭代器的位置。back_insert和front_insert默认的迭代器位置就在容器的尾部和首部。
```

```c++
//插入迭代器的操作
it=t;
//这一步看似简单，但在底层调用了对应容器的插入方法

*it it++ ++it    //不执行任何操作，返回it
```

```C++
//一个例子

```



##### iostream迭代器

首先明确，iostream类不是容器。但其次我们要明白，泛型算法的本质是迭代器的操作，与其底层是否是容器无关。只要是该类型有定义对应的迭代器，就可以作为输入范围。例如数组的指针（begin(num),end(num)）就可以作为泛型算法的输入范围。因此，iostream迭代器在这里是有必要介绍的。



### 4.迭代器分级

输入迭代器   

要求：

istream_iterator

输出迭代器

ostream_iterator

前向迭代器

forward_list中定义的迭代器

双向迭代器

list中定义的迭代器

随机访问迭代器

vector,string,array和deque中定义的迭代器

对于每个泛型算法，都规定了其所能接受的最低等级的迭代器，我们在使用之前一定要清楚这一点。

### 5. 泛型算法参数形式

```c++
algorithms(begin,end,arg);
algorithms(begin,end,dest,arg);
algorithms(begin1,end1,begin2,arg);
algorithms(begin1,end1,begin2,end2,arg);
```

> 使用dest和begin2的版本之间有什么不同？
>
> begin2一般会被认为是第二个序列的开始 dest会被认为是一个目的序列的开始？

### 6. 泛型算法的重载



### 6.特定容器算法

list和forward_list

```C++

```


## 拷贝控制

### 1. 默认构造函数

默认的含义是：默认构造函数定义了该类的默认初始化和值初始化行为。不要认为默认构造函数一定是默认生成的。但是**任何类都必须有默认构造函数**。这就需要我们清楚什么时候默认构造函数才会由编译器构建。

只有在我们并未定义任何其他形式的默认构造函数的情况下，编译器才会帮我们生成一个合成默认构造函数。

如果定义了其他形式的构造函数，那编译器就不会帮我们生成默认构造函数，这时必须由我们手动定义。

**总结：也就是说，对于一个类的构造函数，有两种方式：要么什么也别写，躺平依赖编译器帮助；要么自己动手，一旦动手就要动全套。**

**但是，有的时候就算你想躺着，也不行：有时合成版本会定义为删除的**。

**合成版本遵循以下原则：**

1. 对于有类内初始值的变量，使用类内初始值初始化。
2. 对于没有类内初始值的变量，按其类型进行默认初始化。（即内置类型和复合类型产生未定义的值，其它类型变量调用其默认构造函数）

总结：使用类内初始值或默认构造函数。

**因此，在下列情况下，合成版本被定义为删除的：**

- 某成员的类并没有定义默认构造函数。
- 如果类中的引用成员没有类内初始值或const成员没有类内初始值**且其类型未显式定义默认构造函数**，则该类的默认构造函数被定义为删除的。
- **某成员的类其析构函数是删除或不可访问的。**

在手动定义默认构造函数时，如果觉得合成版本的默认构造函数适用，可以直接指定其使用默认的行为。

```c++
class A{
	A()=default;
};
```

> by the way 数组中能存放的类型是否只能是内置类型的？

> 虽然我们说一个类必须定义其默认构造函数，但是编译器却并不能帮助我们保证这一点。也就是说，没有默认构造函数的类也是可以编译通过的。对吗？

> 为什么上面提到“且其类型未显式定义默认构造函数”？

##### 类中的内置类型成员和复合类型成员有必要初始化

**定义在块作用域内的内置类型和复合类型变量（例如数组和指针）如果被默认初始化，将含有未定义的值。**

> 引用在定义时必须进行初始化，否则编译器会报错，因此这点无需担心。
>
> const好像也必须进行初始化吧？对的，const对象一旦创建后其值就不能改变。但是这应该只针对于const引用和const变量，对const的引用=常量引用
>
> 指向常量的指针并不是代表指针是常量。

```c++
int i=0;
int j=1;
const int *p=&i;
p=&j;

//如果const int *const o=&i
//那么p=&j就会报错。从这个角度来说，const对象必须初始化并没有任何错误
//对const的引用和指向const的指针，严格来讲，并不是const对象，这里const是一个修饰符，代表对权限进行了限制。
```

指针在定义时有必要进行初始化，否则指针会含有未定义的值，如果该指针指向的位置恰好有值存在，那就会引发非法的操作。如果不知道初始化值是什么，那就将指针初始化为空指针，表示其并未指向任何对象。

> 指针，属于内置类型吗？不属于。
>
> 内置类型（built-in types）也被称为基本类型（foundamential types）内置类型包括：int,bool,float,double,void,char
>
> 任何类型，只要不是基本类型，那就是复合类型。因此指针，引用，数组，自定义类都属于复合类型。
>
> 数组如果在定义时未被初始化，则其元素会被默认初始化。如果部分元素未被初始化，则剩余元素会被默认初始化。如同array
>
> 指针的初始化原理与内置类型相同。在块作用域内被定义的指针如果没有被初始化，也将拥有一个不确定的值。但shared_ptr默认初始化为空指针

如何将指针初始化为空指针，共有三种方法：

```c++
//最常用的nullptr C++11标准
//nullptr可以转换成其他任意类型的指针，这也是给任意类型指针
int *p=nullptr;

//赋0
int *p-0;
//最后一种是继承自C语言的方式,NULL预处理变量，现代C++尽量避免使用NULL
#include<cstdlib>
int *p=NULL;
```

还用过哪些预处理变量？

预处理变量不属于命名空间std

### 2. 直接初始化与拷贝初始化

https://blog.csdn.net/ljianhui/article/details/9245661

直接初始化：不使用=

拷贝初始化：使用=

```c++
T a;
T b(a);
//这里的b调用了拷贝构造函数，那是属于拷贝初始化还是直接初始化呢？
属于直接初始化，但是调用了拷贝构造函数
//换句话说，拷贝初始化与直接初始化的区别是是否使用=还是是否使用拷贝构造函数呢
是是否使用=
```

**直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。**直接初始化也可能会调用拷贝构造函数。

拷贝初始化的发生节点：

1. 使用=初始化变量
2. 将一个对象作为实参传递给非引用类型的形参
3. 从一个返回类型为非引用类型的函数中返回一个对象
4. 使用花括号列表初始化一个数组中的元素或一个聚合类中的成员

能使用

```c++
vector<int> a{}; //是否等价于
vector<int> a({})

vector<int> a={};
即列表初始化的对象
```

重载=运算符



```c++
StrVec &operator=(std::initialized_list<string> il) //用于 ={}的形式
StrVec(std::initialized_list<string> il)
```

### 运算符

有一元运算符和二元运算符之分，区别是其作用的对象的数量。有的运算符，例如*，既是一元运算符又是二元运算符，只不过含义不同，其实我们可以将其理解为不同的运算符。具体含义具体分析。



运算符得到的结果（即表达式）有左值和右值这两种属性之分。拥有左值属性的表达式同时可以作为右值，但是拥有右值属性的表达式只能作为右值。

左值：赋值运算符，前置递增运算符

右值：算术运算符，关系运算符，逻辑运算符，后置递增运算符

**前置递增运算符返回左值，有没有一个好的例子证明一下？**



### 类：列表初始化和列表赋值

=有可能用于初始化和赋值

但是赋值只能用=，初始化还有别的方式

初始化->构造函数

赋值->赋值运算符

**拷贝构造函数：允许使用同类对象初始化** 1，3

**拷贝赋值运算符：允许使用同类型对象赋值，注意operator并不能控制初始化！** 5



1. T（T）：拷贝构造函数
2. T=T（初始化）：拷贝构造函数
3. T（{}）：（{}）
4. T={}（初始化）：（{}）+ 拷贝构造函数     只有（{}）不行，拷贝构造函数必须可见？？试验了是可以的
5. T=T（赋值）： 拷贝赋值运算符
6. T={}（赋值）：={} or ({})+拷贝赋值运算符 同时有的话会调用哪一个?operator=



operator=只能用于赋值，不能用于初始化,因此只有operator=的类，不能使用={}方式初始化，
但是可以用={}赋值。用途比较狭窄。对于能够将{}转换成本类型的类，没必要单独定义operator={}

（{}）在拷贝构造函数或拷贝赋值运算符的帮助下还能够做到使用{}初始化和赋值。
其本质是借助了隐式的类型转换，（{}）实质是提供了一个类型转换的平台



因此，如果想要实现某类的列表初始化，必须定义形如

```c++
StrVec(std::initializer_list<T> il)
```

的构造函数。

如果想要实现某类的列表赋值



实参是形参的初始值。实参用于初始化形参。

返回的值用于初始化调用点的一个临时无名变量，该临时量就是函数调用的结果。



### 什么时候编译器会帮我们自动生成构造函数和拷贝控制成员？

默认构造函数：只有没有定义任何构造函数，编译器才会为我们生成合成默认构造函数。如果自行定义了其他任何一个构造函数却没有定义默认构造函数，则编译器不会为我们生成默认构造函数。

拷贝构造函数：如果我们没有定义，编译器帮我们生成合成拷贝构造函数。

拷贝赋值运算符：如果我们没有定义，编译器帮我们生成合成拷贝赋值运算符。

析构函数：如果我们没有定义，编译器帮我们生成合成析构函数。

移动构造函数：只有没有定义以上三种拷贝控制成员，且数据成员都是可移动的，编译器才会帮我们生成合成移动构造函数。

> 什么样的成员是可移动的：内置类型和定义了移动构造函数的类。

移动赋值运算符：同上。

总结：一个类中不可能没有前三种拷贝控制成员，因为就算我们不显式定义，编译器也会帮我们自动生成一个合成的版本。但是对于移动构造函数和移动赋值运算符，只有在没有显示定义以上三种拷贝控制成员且成员都可移动时，编译器才会帮我们隐式定义合成的版本。 

##### 如果析构函数是删除的

```c++
class NoDtor{
    NoDtor()=default;
    ~NoDtor()=delete;   
};

NoDtor nd;     //error:不允许在栈内存中创建一个析构函数是删除的对象
NoDtor *p=new NoDtor(); //编译正确：允许在栈内存中创建一个析构函数是删除的对象，但是这样做其实没有好处
delete p;//错误：由于析构函数是删除的，我们无法删除该对象。
```

我们不允许在静态内存或栈内存中创建一个析构函数是删除的对象，因为在这部分内存中的对象是由编译器负责销毁的，因此编译器需要获取其析构函数以删除该对象。

但是我们允许在动态内存中创建一个析构函数是删除的对象。因为在动态内存中的对象编译器本身并不负责其销毁过程，这一部分是要求程序员负责的，因此编译器在创建该对象时并不需要获取其析构函数。但是同时，由于析构函数是删除的，就算我们在动态内存中创建了一个该类型对象，我们也没有办法将其删除。

> 开发过程中这一点是可以利用的吗？如果这种办法一无是处，这样做会导致什么后果呢？或者操作系统本身有办法解决这种问题吗？
>
> 目前已知的：使用智能指针，并在定义时传入一个删除器。这样当智能指针对象被销毁时，会自动调用删除器而不是默认的delete p释放内存。这个删除器一般是如何定义的？它为什么能够完成删除功能？
>
> 既然可以定义删除器，那么反过来，我们也可以继续使用内置指针，只不过把原来的delete p改为删除器函数即可。对吗？

https://stackoverflow.com/questions/35730462/how-are-dynamic-objects-of-a-type-with-a-deleted-destructor-constructed

因此，总结来看，析构函数不能定义为删除的。如果定义为删除的，这种类型的对象根本无法创建，就算动态内存中真的创建，也没有办法销毁。**在我目前看来，析构函数定义为删除的类基本等于废了。**

析构函数

成员的析构部分会自动帮我们完成。我们只需要对该类所管理的内存资源进行释放即可。

### 总结：编写构造函数+拷贝控制成员的步骤

类的拷贝：对每个数据成员都进行拷贝工作。要求数据成员及其管理的内存都是可拷贝的

内置类型：i=p.i

指针：浅拷贝：ps=p.ps  深拷贝：ps=new T(*p.ps)

类：执行其拷贝

类的移动：对每个数据成员都进行移动工作。要求数据成员及其管理的内存都是可移动的

内置类型：i=p.i 内置类型的拷贝与移动没有区别

指针：ps=p.ps  p.ps=nullptr

类：执行其移动

移动之后的被移动对象处于可析构状态，但其管理的内存已经被接管了，但里面的数据已经废掉了。

拷贝之后的被拷贝对象其数据仍旧能够继续使用。

因此，我们选择使用拷贝还是移动，完全取决于程序员希望被拷贝（移动）的对象会执行什么行为。可以只定义拷贝相关的操作。当然也可以两种操作同时定义，这时编译器会使用函数匹配机制帮我们自动选择使用哪种操作。对于含有不能拷贝成员的



首先明确概念：构造函数用于初始化，赋值运算符用于赋值。移动用于避免拷贝，提高效率。

我们知道，拷贝构造函数在以下几种情况下会被使用：

1. 使用同类型对象初始化
2. 使用实参初始化该类型的形参
3. 作为返回值
4. 聚合类

有的时候，被拷贝的对象在完成初始化的任务之后并没有其他用处了，这一点尤其是在2,3中非常明显。因此，我们提出“移动”的概念，希望直接接管被拷贝对象的资源，而不是

什么样的类进行移动会获得好处：类的数据成员拷贝起来非常费时间，类所管理的内存资源很庞大。



对于内置类型，移动与拷贝并无区别。

对于指针类型，如何控制其拷贝行为决定了该类是类值还是类指针。类值的类希望在拷贝时希望每个对象都保存其独有的副本，而类指针的类希望在可拷贝时拷贝与被拷贝的对象之间共享副本。这只是一种选择而已，选择类值还是类指针的行为取决于程序员希望这个类应该表现出什么样。

##### 拷贝的行为是类值的还是类指针的可以指导我们的设计含有该类对象的类的拷贝行为

例如，假设HasPtr是一个类指针类，假设某个名为Data的类中有一个HasPtr类的成员p。那么在设计Data的拷贝构造函数或拷贝赋值运算符时，p(rhs.p)or p=rhs.p的操作就会被认为是进行了类似指针的浅拷贝，被拷贝对象和拷贝对象共享同一份内存资源。而如果HasPtr是一个类值的类，那么p(rhs.p)or p=rhs.p的操作就会被认为是进行了类似值的拷贝，拷贝对象只是对被拷贝对象的资源进行了复制，两个对象并不共享内存资源。

总结来说，某个类的拷贝构造函数和拷贝赋值运算符所表现出来的类指针或者类值行为，当拷贝该类对象时，我们就可以把该类像值或者像指针那样对待。

如果某个类中全都是类值数据成员，那还有必要定义移动构造函数和移动赋值运算符吗？

HasPtr是类值的，没错，我们来看看它的成员： string *p和一个int。在拷贝的时候，我们对p进行了深拷贝，使其能够表现出类值行为。移动行为：



为一个类编写移动构造函数，就是定义其整体的移动行为：对每个成员进行移动。

对于内置类型，移动拷贝无所谓。对于指针类型，移动拷贝无所谓，其本质都是值。

对于类，调用其移动构造函数或移动赋值运算符。

```c++
//对于成员访问运算符.当左侧运算对象是左值时，返回值是左值；当左侧运算对象是右值时，返回值是右值
//因此，对于
```



但是还有一个问题，并不是类的所有数据成员都可以被拷贝，例如unique_ptr和iostream对象就不可以被拷贝。在这种情况下，

所以类值的类不需要移动构造函数（赋值运算符）

类值，类指针，指的是其在被拷贝时的行为，而并不是其是否需要移动和拷贝的操作。



如果类中所有的指针都使用智能指针，那就完全可以不用担心资源的释放问题。



内置类型直接拷贝，类类型调用其拷贝构造函数。

对于内置类型和类值类型，直接拷贝。对于指针以及类指针的类，考虑清楚是进行深拷贝还是浅拷贝。

##### 拷贝构造函数

- 对于拷贝对象：

  由于是构造行为，因此本对象还并未分配资源。与赋值运算符相比，不需要考虑资源的释放问题。

- 对每个成员进行拷贝初始化。

- 对于被拷贝对象：

  由于是进行拷贝赋值，不需要对被拷贝对象做任何的改动。

##### 拷贝赋值运算符

- 对于拷贝对象：

  如果类中有内置指针成员，需要考虑是否需要释放该指针的指向的资源。对于智能指针，它会自动帮我们考虑。

- 对每个成员进行拷贝赋值。

- 对于被拷贝对象：

  由于是进行拷贝赋值，不需要对被拷贝对象做任何的改动。

##### 移动构造函数

- 对于移动对象：

  由于是构造行为，因此本对象还并未分配资源。与赋值运算符相比，不需要考虑资源的释放问题。

- 对每个成员进行移动初始化。

- 对于被移动对象：

  如果类中有内置指针成员，需要**指向资源的指针**置为不可用状态（nullptr）。对于智能指针，它会自动帮我们完成。

> 注意，我们必须对管理内存资源的指针置为空，对于其它功能的指针，例如用于引用计数的指针，修改其值可能会存在风险。详情参见HasP类的移动构造函数和移动赋值运算符。

##### 移动赋值运算符

- 对于移动对象：

  如果类中有内置指针成员，需要考虑是否需要释放该指针的指向的资源。对于智能指针，它会自动帮我们考虑。

- 对每个成员进行移动赋值。

- 对于被移动对象：

  如果类中有内置指针成员，需要**指向资源的指针**置为不可用状态（nullptr）。对于智能指针，它会自动帮我们完成。

##### 析构函数

- 释放该类所管理的内存资源。对于智能指针管理的内存，我们无需理会。我们只需要对内置指针管理的内存进行手动释放即可。

智能指针与内置指针：

现在C++程序直接使用智能指针。因为它不需要瞻前顾后的考虑以下问题：

1. 在赋值之前，考虑是否需要对源对象的资源释放问题。如果需要，需要手动释放。
2. 在移动之后，将指向资源的指针置为不可用状态。


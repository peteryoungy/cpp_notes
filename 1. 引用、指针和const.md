

## 引用和指针，const修饰的引用和指针 

### 引用

### 指针

### const限定符

#### 1. const作用于普通类型变量

const作用于变量的意义就是使变量变成常量。（可以认为是常量，但其实是只读，并不完全是常量，常量在后面另有说法）任何涉及到其值修改的操作都被认为是非法的。由此，常量在定义的时候就必需初始化。例如：

```c++
int i=42;
const int r1=i;
const int r2=42;
const int r3=get_value();
//以上操作都是正确的，只要等号右边能够返回一个确定的数值即可。
```

#### 2. const作用于引用

const作用于引用的意义是使引用的权限受限。任何试图利用引用修改原变量值的操作都不被允许。当对常量进行引用时，引用也必须是const，但是反过来，我们却可以对变量进行对const的引用。

我们一般把对const的引用称为“常量引用”。但是这里注意与常量指针的区别，这两个名词看起来“结构”一样，但是却代表不同的含义。常量引用指的是引用的权限是“常量”的；而常量指针并不代表指针的权限是“常量”的。它指的是指针本身是一个常量，即指针指向的地址值不被允许改变。事实上，引用并不存在常量非常量一说，因为引用本身并不是一个对象，而指针不同，指针代指一个对象。引用本身的定义就不允许其更改所绑定的对象，因此，从这个角度来看，引用永远都是“常量”的。但如果不指定指针是常量的，那么指针指向的对象可以被随意的改变。

```c++
int i =42;
const int &r1=i;
const int &r2=42;
const int j= 5;
const int &r3 =j;
int &r4=j;   //这一句错误，当所绑定对象是const，引用必须是const,引用的权限不能凌驾于所绑定对象之上。
```

**普通引用并不允许我们将引用绑定到字面值常量上，但是常量引用可以绑定到字面值常量上。**（从这个角度来看，字面值常量还真的是“常量”）而且所谓的”引用必须要绑定一个对象“在这里也失效了。

#### 3. const作用于指针

在指针中有两个名词：常量指针和指向常量的指针。其中，常量指针与指针的权限毫无关系。它的意义是不允许指针更改其所绑定的对象，即内存中的地址值。同样的，与引用一致，常量指针在定义时必须初始化。

指向常量的指针对指针的权限做出了限制。它规定了不允许程序员通过该指针做出有关修改其所绑定对象值得操作。同样的，防止权限凌驾，如果指针指向的对象是常量的，那么我们必须令指针为指向常量的指针。我们可以认为常量引用和指向常量的指针其实是一类。而常量指针是另一类。

```c++
int i=0;
int *r1=i;
int r2=&i;
const int *r3=i;  //定义指向常量的指针
int *const r33=&i; //注意常量指针的表达方式
const int *const r4=&i; //指针是否是常量指针与它所指向的对象没有一点关系
const int j=1;
const int *r5=&j; //j本s是常量，那么r5必须指向常量
int *const r55=&j; //错误，j为const，那么指针也必须为指向常量的指针，前面
const int *const r6=&j; 

//判断指针类型的技巧，从右往左读 例如
const int *const r4=&i
//最右边是 *const，则r4为常量指针，再往左是int，表明其指向int类型，最左边是const，表明其权限是const的。可以这样想，*以及其右边表示指针以及指针本身是否是一个常量，而*左侧表示指针所指向对象的类型，以及对该对象的权限是否是const的。
```

#### 4. 顶层const与底层const

最初，这是单独为指针而提出的两个名词。顶层const指的是指针本身是常量，即常量指针，而底层const指的是指向const的指针。

更一般地，我们把任何常量对象都可以称顶层const，而底层const可以指引用或者指针的权限。

当执行**拷贝赋值**时，忽略顶层const，但底层const不能忽略。可以让非底层const对象拷贝给底层const对象，但反过来并不可以。

**注意：仅当=左右对象类型相同时，才可以忽略顶层const； 当=左右对象类型并不相同，那该语句并不是拷贝赋值而是定义，那么顶层const必须也被考虑进来。**

```c++
int i=0;
int *const p1=&i;    //p1是一个常量指针
const int ci=42;	 //ci是常量
const int *p2=&ci;   //顶层const和底层const配对上了
//p2是一个指向const对象的指针
const int *const p3=p2; //初始化不可以让权限扩大，只能让权限缩小，p3是一个指向const对象的常量指针
const int &r=ci;   //r是常量引用

//赋值时，忽略顶层const，但是初始化不可以忽略顶层const
i=ci;   //正确，忽略ci的顶层const
p2=p3;	//正确，忽略p3顶层const之后，p2与p3类型相同

int *p=p3; //不正确 p3有底层const，p没有。p3有顶层const，p也没有。但是！这里只需要p有底层const就可以通过！
p2=p3;
p2=&i;	//正确，权限缩小
int &r=ci;	//不正确，ci有顶层const
const int &r2=i; //正确，权限缩小
```

#### 5. const作用于成员函数

const的最后一种作用是作用于成员函数，使其成为常量成员函数（const成员函数）其格式例如：

```c++
std::string Sales_Data::isbn() const{
    return bookNo;
}
```

可以看到，除了一些常规操作，在函数（）之后{}之前，还加上了const限定符。它的作用是修改this指针为指向常量的指针。在C++类的每个成员函数中，存在一个隐式指针this，this为指向非常量的常量指针，指向对象本身（类似于python中的self）。我们希望定义一个对象，使其在使用过程中不会对其成员进行修改，我们称之为常量对象。但是由于this是指向非const的(指向非const的指针只能指向非const对象，而指向const的指针，既可以指向非const对象，又可以指向const对象)，因此常量对象在调用成员函数时会产生错误。为了解决这个问题，我们把那些不涉及成员修改的成员函数的this指针权限修改为const，使得常量对象能够调用。这类成员函数就被称为常量成员函数。这种方式大大提高的成员函数的灵活性。



其他

```c++
#include<iostream> //不是ostream

using namespace std; //本文件中使用到的名字全部位于std namespace中

using std::cout //仅有cout函数可以省略前面的std::，其他名称如vector，string还是要在前面加上std::
    
//函数的声明与定义
//声明放于main函数之前，定义放于文件底部扎堆，主函数放于文件中间，预处理命令和作用域声明放于文件开头
```

## 引用 &

& *具有多重含义P48   & 用于定义，表示引用； 用于

如何理解复合类型的声明P51




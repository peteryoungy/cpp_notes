## 一、迭代器

##### 1.1 简介

迭代器是被所有C++标准库容器都支持的访问方式。同时string类型虽然不是容器类型，也支持使用迭代器方式访问。

前面讲到string和vector都可以使用下标方式访问元素，但不是所有的C++标准库容器都支持下标的方式。在容器中更加一般化的访问方式就是迭代器。

迭代器有有效和无效之分。有效迭代器的范围在begin()和end()之间（包括end），其余的都是无效迭代器。

##### 1.2 如何生成迭代器

```c++
vector<int> v1;
auto it1=v1.begin();
auto it2=v1.end();
```

begin()返回第一个元素的迭代器，end()返回最后一个元素迭代器的位置+1，被称为尾迭代器。

##### 1.3 迭代器类型

**事实上，日常的使用我们并不需要关心迭代器的类型是什么，因为可以用auto进行推断，但是如果想让函数返回一个迭代器，就不得不清楚迭代器的类型是什么。**

迭代器的类型有两种，一种是普通迭代器iterator，另一种是常量迭代器const_iterator。const_iterator类似于指向const的指针，该类型的迭代器没有对元素进行修改的权限。const_iterator可以指向普通对象和const对象，而iterator只能指向普通对象。

当使用begin()和end()时，返回的迭代器类型取决于对象是否是常量，如果对象不是常量，返回iterator类型，如果不是常量，返回const_iterator类型。

```c++
vector<int> v1;
const vector<int> v2;
auto it1=v1.begin();  
//因为v1是普通对象，因此it1是iterator类型
auto it2=v2.end();
//因为v2是const对象，因此it2是const_iterator类型
```

但有时尽管对象不是const对象，我们也想返回const迭代器，这时可以使用cbegin()和cend()，无论对象是否是常量，均返回const_iterator类型的迭代器。

**迭代器类型不能单独使用，使用前必须加上它所指向的容器类型或string类型,并使用：：链接。**

```
vector<int>::iterator it1=v1.begin();
vector<int>::const_iterator it2=v1.cend();
```

**<u>容器类型是否是const和其元素是否是const对象的有什么关系？</u>**

##### 1.4 迭代器的运算

```c++
*iter	//解引用，返回迭代器所指元素的引用
iter->   //当迭代器指向对象是类，可以通过->访问其成员对象
++iter
--iter
iter1==iter2
iter1!=iter2
```

由于end返回的迭代器并不实际指某个元素，所以不能对其进行++或*，->的操作，但是可以进行--和比较。

对迭代器最好的理解就是，当使用算术运算符和比较运算符时当成数组下标，当使用*和->运算符时当成指针。

string和vector的迭代器还额外支持以下运算：

```c++
iter+n
iter-n
iter+=n  
iter-=n
iter1-iter2
< <= > >=
```

##### 1.5 练习：用迭代器访问的方式完成二分查找的代码

总结几点：

- iterator并不是一个单独的类型，使用iterator时前面一定要加上其所指向的对象类型，例如函数在头文件中的声明：

```c++
std::vector<int>::iterator binarySearch(std::vector<int> &nums,int target);
```

- 由于end()返回尾后迭代器，可以直接使用左闭右开区间的方式进行二分查找，当然也可以先将尾后迭代器-1，再使用左闭右闭区间的方式二分查找
- 如何返回一个“空”迭代器：返回nums.end()即可。

## 二、数组

定义数组，定义数组的指针，定义指向数组首元素的指针

运算符优先级: * （）【】

```
int a[5] = {1,2,3,4,5};
int a[] = {1,2,3,4,5};
int a[6] = {1,2,3,4,5};

int (*pa)[] = a;

```



##### 2.1 数组的定义与初始化

- 数组支持列表初始化
- 与vector不同的是，数组并不能用于初始化其他数组或对其他数组赋值。原因也可以理解，当使用数组名的时候，编译器都会将其当作是一个指向数组首元素的指针。

##### 2.2 数组指针与数组引用

```C++
int arr[10];
int (*parray)[10]=&arr;   //数组的指针，注意，[10]是有意义的，不能多也不能少，必须跟数组的大小一致。
int (&arrRef)[10]=arr;		//数组的引用，注意，[10]是有意义的，不能多也不能少，必须跟数组的大小一致。
int *p=arr;		//指向数组首元素的指针
```

数组的引用和数组的指针，既然是与数组有关的，那么必须要知道数组的大小，否则和普通的指针，普通的引用有什么区别呢？因此，在定义数组的指针和引用时，[10]非常重要，必须严格和数组的大小一致。这里注意区分，定义数组时，[size]里面的值不一定会被全部初始化，列表里元素的个数可以小于size。

##### 2.2 如何理解复杂的数组定义

方法论：

##### 2.3 指向数组首元素的指针

数组名通常可以被认为是一个指向数组首元素的指针。和普通指针相比，它有着

###### 2.3.1 其迭代器特性

指向数组元素的指针可以获得迭代器的特性，支持vector和string中迭代器的所有操作。

```c++

```

###### 2.3.2 获取首尾指针的方式

可以通过对数组元素取地址的操作获取首指针和尾指针。但这种方式充满了风险。

```c++
int a[]={0,1,2,3,4,5,6,7,8,9};
int *p1=a;
int *p2=&a[10];
//这里a[10]本来应是一个越界操作，但在定义指针时可以使用。
```

比较安全的办法是通过begin()和end()获取首尾元素指针。

```c++
int a[]={0,1,2,3,4,5,6,7,8,9};//
int *p1=begin(a);
int *p2=end(a);
```

## N维数组

定义N维数组时，除了第一个维度的大小可以省略，其他维度必须规定大小。

```c++
int a[][] = {{1,2,3},{4,5,6}};

```



## C风格字符串

C风格字符串指的是使用字符数组保存字符串的值，并且以/0字符作为结尾。

有关C风格字符串的操作在C语言标准库中有所定义，C++新标准下可以include<>

```c++
strlen(p1);
strcmp(p1,p2);
strcat(p1,p2);

```

C++中尽量使用string类型而不要使用C风格字符串。